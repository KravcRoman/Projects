# Мини-сервис управления видеопотоками

Этот проект представляет собой API для управления видеопотоками, включая загрузку информации о видео, генерацию HLS-плейлиста (фейковую), кеширование данных в Redis и асинхронную обработку событий.

## Стек технологий

* **Python**: 3.12
* **FastAPI**: Веб-фреймворк
* **PostgreSQL**: Реляционная база данных
* **SQLAlchemy**: ORM для работы с PostgreSQL (с асинхронной поддержкой)
* **Alembic**: Инструмент для миграций базы данных
* **Redis**: In-memory СУБД для кеширования
* **Docker & Docker Compose**: Контейнеризация и оркестрация сервисов
* **Uvicorn**: ASGI сервер для FastAPI
* **Pydantic**: Валидация данных
* **BackgroundTasks (FastAPI)**: Для асинхронной обработки задач

## Функциональные требования

1.  **API для загрузки информации о видео**
    * `POST /api/videos`
    * Принимает `title` и `url` видео.
    * Возвращает `id`, `title` и `playlist_url`.
2.  **API для получения информации о видео**
    * `GET /api/videos/{id}`
    * Возвращает информацию о видео.
    * Данные кешируются в Redis.
3.  **Генерация HLS-плейлиста**
    * При загрузке нового видео генерируется фейковый HLS-плейлист (`.m3u8`).
4.  **Асинхронная обработка**
    * Событие о загрузке видео обрабатывается в фоновом процессе: генерация HLS (основная часть, если бы она была тяжелой), запись в кеш, логирование.

## Структура проекта

```text
video_service/
├── app/
│   ├── __init__.py
│   ├── main.py             # Главное приложение FastAPI, эндпоинты
│   ├── crud.py             # Функции для взаимодействия с базой данных (CRUD)
│   ├── database.py         # Настройка подключения к базе данных (SQLAlchemy)
│   ├── models.py           # Модели SQLAlchemy (схема таблиц БД)
│   ├── schemas.py          # Схемы Pydantic (для валидации данных запросов/ответов)
│   ├── tasks.py            # Фоновые задачи (генерация HLS, кеширование, логирование)
│   ├── cache.py            # Функции для работы с Redis
│   └── core/
│       ├── __init__.py
│       └── config.py       # Конфигурация приложения (чтение .env)
├── alembic/                # Файлы миграций Alembic
│   ├── versions/           # Сгенерированные миграции
│   ├── env.py              # Конфигурация окружения Alembic
│   └── script.py.mako      # Шаблон для новых миграций
├── tests/                  # Юнит-тесты
│   ├── __init__.py
│   ├── conftest.py         # Общие фикстуры для тестов
│   └── test_api.py         # Тесты для API эндпоинтов
├── .env_example            # Пример файла с переменными окружения
├── .gitignore              # Файлы, игнорируемые Git
├── alembic.ini             # Конфигурация Alembic
├── Dockerfile              # Dockerfile для сборки образа приложения
├── docker-compose.yml      # Файл для оркестрации контейнеров Docker Compose
├── requirements.txt        # Зависимости Python
└── README.md               # Инструкции по запуску и описание проекта
```

## Подготовка к запуску

1.  **Установите Docker и Docker Compose.**
    * Инструкции: [Docker](https://docs.docker.com/get-docker/), [Docker Compose](https://docs.docker.com/compose/install/)

2.  **Создайте файл `.env`**
    Скопируйте `.env_example` в `.env` и заполните необходимые значения:
    ```bash
    cp .env_example .env
    ```
    Отредактируйте `.env` (пароли, имена пользователей и т.д., если требуется). Значения по умолчанию подходят для локального запуска с `docker-compose.yml` из этого репозитория.

## Запуск с использованием Docker Compose

1.  **Сборка и запуск контейнеров:**
    Находясь в корневой директории проекта (`video_service/`), выполните:
    ```bash
    docker-compose up --build -d
    ```
    Флаг `-d` запускает контейнеры в фоновом режиме.
    При первом запуске `--build` обязателен. В последующие разы, если не было изменений в `Dockerfile` или `requirements.txt`, можно просто `docker-compose up -d`.

2.  **Применение миграций базы данных (Alembic):**
    После того как контейнер `db` запустится и будет готов (Docker Compose позаботится об этом благодаря `healthcheck` и `depends_on`), нужно применить миграции.
    Вы можете сделать это, выполнив команду внутри запущенного контейнера `app`:
    ```bash
    docker-compose exec app alembic upgrade head
    ```
    *Примечание: При первом запуске `app.main:create_db_and_tables()` также попытается создать таблицы на основе моделей. Для продакшена рекомендуется полагаться только на Alembic и убрать `create_db_and_tables()` из `on_startup`.*

3.  **Проверка работы сервиса:**
    * API будет доступен по адресу `http://localhost:8000`.
    * Документация OpenAPI (Swagger UI): `http://localhost:8000/docs`
    * Альтернативная документация ReDoc: `http://localhost:8000/redoc`
    * Проверка здоровья: `http://localhost:8000/health`

## Остановка сервиса

```bash
docker-compose down
```

Если вы хотите удалить также и volumes (данные PostgreSQL и Redis):
```bash
docker-compose down -v
```

## Локальная разработка (без Docker, если необходимо)

1.  Создайте и активируйте виртуальное окружение:
    ```bash
    python -m venv venv
    source venv/bin/activate  # для Linux/macOS
    # venv\Scripts\activate    # для Windows
    ```
2.  Установите зависимости:
    ```bash
    pip install -r requirements.txt
    ```
3.  Запустите PostgreSQL и Redis локально или используйте Docker для них.
4.  Убедитесь, что файл `.env` настроен на подключение к вашим локальным экземплярам БД и Redis.
5.  Примените миграции Alembic:
    ```bash
    alembic upgrade head
    ```
6.  Запустите FastAPI приложение:
    ```bash
    uvicorn app.main:app --reload
    ```

## API Эндпоинты

### 1\. Загрузить информацию о видео

  * **URL:** `/api/videos`
  * **Метод:** `POST`
  * **Content-Type:** `application/json`
  * **Тело запроса:**
    ```json
    {
      "title": "Название Видео",
      "url": "[http://example.com/video.mp4](http://example.com/video.mp4)"
    }
    ```
  * **Успешный ответ (201 CREATED):**
    ```json
    {
      "id": 1,
      "title": "Название Видео",
      "playlist_url": "http://localhost:8000/hls/1.m3u8"
    }
    ```
  * **Ошибки:**
      * `409 Conflict`: Если видео с таким `original_url` уже существует.
      * `422 Unprocessable Entity`: Если данные запроса невалидны.

### 2\. Получить информацию о видео

  * **URL:** `/api/videos/{id}`
  * **Метод:** `GET`
  * **Успешный ответ (200 OK):**
    ```json
    {
      "id": 1,
      "title": "Название Видео",
      "original_url": "[http://example.com/video.mp4](http://example.com/video.mp4)",
      "playlist_url": "http://localhost:8000/hls/1.m3u8",
      "created_at": "2025-05-14T10:00:00.000Z",
      "updated_at": "2025-05-14T10:00:00.000Z"
    }
    ```
  * **Ошибки:**
      * `404 Not Found`: Если видео с указанным `id` не найдено.

## Юнит-тесты

Для запуска тестов:

1.  Убедитесь, что у вас установлены зависимости для тестов (pytest, pytest-asyncio, httpx).
2.  Тесты обычно требуют отдельной конфигурации для тестовой БД.
3.  Команда для запуска тестов из корневой директории:
    ```bash
    pytest
    ```

## Дальнейшие улучшения (TODO)

  * **Полноценная генерация HLS**: Интеграция с `ffmpeg` для реальной сегментации видео.
  * **Хранение HLS плейлистов и сегментов**: Использование файлового хранилища или объектного хранилища (S3, MinIO).
  * **Более надежные фоновые задачи**: Рассмотреть Celery или RQ для более сложных сценариев, требующих очередей сообщений, повторных попыток и т.д.
  * **Аутентификация и авторизация**: Защита эндпоинтов.
  * **Развернутое логирование**: Более детальное и структурированное логирование.
  * **Полное покрытие тестами**: Написать юнит-тесты для CRUD операций, задач и бизнес-логики.
  * **CI/CD**: Настройка автоматической сборки, тестирования и развертывания.
  * **Валидация URL видео**: Проверка доступности и формата видео по URL.
  * **Обработка ошибок**: Более гранулярная обработка ошибок и возврат информативных сообщений.

<!-- end list -->
